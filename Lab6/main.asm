;
; Programa Proyecto Final
;
; Created: 12/11/2024
; Author : Lorenzo - Weyrauch - Martony - Zugnoni

; Breve descripción:
; Juego Ta Te Ti
; Defino una memoria de pantalla en RAM de 1024bytes. 1 byte = 1 pixel (32 x 32 = 1024)
; de c/u uso solo 3 bits que indican el RGB del pixel (solo on/off).
;
; configuro el timer0 para interrumpir 1250 veces por segundo.
; luego en cada interrupción barro 1 linea cada vez.
;
; configuro el timer1 para interrumpir 1 vez por segundo, puede utilzar para hacer un reloj.
; por ahora solo modifica el color de 1 pixel para confirmar que el timer1 funciona correctamente.
;
;  Pines de control del display:
;    PB5:PB0 = RGB1:RGB0
;    PC6:PC0 = LE:Clk:OE:ABCD
;
; Importante: la interrupción del timer0 utiliza el registro Y(r29:r28) y r25, no se pueden utilizar en
; otras rutinas.
; Y(r29:r28) - dirección en la RAM de oantalla de la próxima linea a barrer
; r25 - #de linea a barrer en la próxima interrupción.

; aquí defino la memoria pantalla en RAM.
; recordar que la directiva .DSEG aclara que esto va en RAM.
.DSEG
screen:				.byte 1024		;reservo 1024 bytes para la memoria de pantalla.
screen_end:			.byte 1			;solo para marcar el final del buffer

; comienzo del programa principal.
; la directiva .CSEG aclara que esto va en FLASH de programa (y es código).
.CSEG

; declaro los vectores de interrupción
.ORG 0x0000
	; dirección de comienzo (vector de reset)
	jmp		init
.ORG 0x0016
	; rutina de atención de comparación A del timer 1
	jmp		_tmr1_int
.ORG 0x001C
	; rutina de atención de comparación A del timer 0
	jmp		_tmr0_int

; ---------------------------------------------------------------------------------------
; acá empieza el programa
init:
	;-------------------------------------------------------------------------------------
	; configuro los puertos:
	; PB0 PB1 PB2 - RGB0
	; PB3 PB4 PB5 - RGB1

	; PB0 a PB5 son salidas
    ldi		r16,	0b00111111
	out		DDRB,	r16
	; apago PB0 a PB5
	ldi		r16,	0x00
	out		PORTB,	r16

	; TODO: hacer los botones
	; PC0:7 están los botones
	ldi		r16,	0b00000000
	out		DDRC,	r16			;PC0:7 son entradas

	; PD3 a PD0 = ABCD indica la línea del display que estoy escribiendo
	; PD4 = OE (asumo activa nivel alto), PD5 = Clk serial, PD6 = LE (STB del Latch)

	; configuro PD0 a PD6 como salidas
	ldi		r16,	0b01111111
	out		DDRD,	r16
	; apago PD0 a PD6
  	ldi		r16,	0b00000000
	out		PORTD,	r16

	;-------------------------------------------------------------------------------------
	; Configuro el TMR0 y su interrupcion.

	; cuenta hasta OCR0A y vuelve a cero (reset on compare)
	; cuando llega a OCR0A, dispara la interrupción
	ldi		r16,	0b00000010
	out		TCCR0A,	r16
	; prescaler = 256
	ldi		r16,	0b00000100
	out		TCCR0B,	r16
	; comparo con 49
	; f_int0 = f_cpu/(2*prescaler*(OCR0A+1)) = 16000000/(2*256*25) = 1250Hz
	ldi		r16,	24
	out		OCR0A,	r16
	; habilito la interrupción del timer0
	ldi		r16,	0b00000010
	sts		TIMSK0,	r16

	;-------------------------------------------------------------------------------------
	; Configuro el TMR1 y su interrupcion.

	ldi		r16,	0b00000000

	; configuro para que cuente hasta OCR1A y vuelve a cero (reset on compare)
	; cuando llega a OCR1A, dispara la interrupción
	sts		TCCR1A,	r16
	ldi		r16,	0b00001101
	sts		TCCR1B,	r16			;prescaler = 1024
	; OCR1A = 15625
	; f_int1 = 16000000/1024/15625 = 1Hz
	; f_int1 = f_cpu/(2*prescaler*(OCR1A+1)) = 16000000/(2*1024*15625) = 1250Hz
	ldi		r16,	high(15624)
	sts		OCR1AH,	r16
	ldi		r16,	low(15624)
	sts		OCR1AL,	r16
	; habilito la interrupción del timer1
	ldi		r16,	0b00000010
	sts		TIMSK1,	r16

	;-------------------------------------------------------------------------------------
	; Inicializo algunos registros que voy a usar como variables.

	; r25 indica qué línea estoy barriendo del display
	ldi		r25,	0x00
	; Y apunta al primer byte de la pantalla
	ldi		YL,	low(screen)
	ldi		YH,	high(screen)

	;-------------------------------------------------------------------------------------
	; habilito las interrupciones globales(set interrupt flag)
	sei


;Programa principal
start:
	; borra el panel
	call	borra_panel

	; copia una imagen de fondo en el panel
	; apunto Z a la imagen de fondo a copiar y luego efectivamente la copia.
	ldi		ZL,	low(Imagen_1<<1)
	ldi		ZH,	high(Imagen_1<<1)
	call	copia_img

	; Imprime un '0' blanco por pantalla,
	; r18 = numero a imprimir
	; r17 y r16 = Fila y Columna del pixel superior izquierdo del número.
	; r20 = color del caracter. 1-Verde 2-Rojo 4-Azul 3-Amarillo 5-cyan 6-lila 7-blanco 0-apagado
	ldi		r18,	0x00
	ldi		r17,	0x08
	ldi		r16,	0x07
	ldi		r20,	0x07				;en R20 está el color
	call	copia_char

	; Imprime un '1' Verde por pantalla
	ldi		r18,	0x01
	ldi		r17,	0x12
	ldi		r16,	0x09
	ldi		r20,	0x01				;en R20 está el color
	call	copia_char

espero:
	rjmp	espero


;-------------------------------------------------------------------------------------
;copia_img:
;----------
;Rutina que copia un bloque de 1024 bytes de la Flash de programa a la RAM de pantalla
;en Screen.
;
;Parámetros: debo poner en Z(ZH:ZL) la dirección de comienzo de la imagen a copiar.
;-------------------------------------------------------------------------------------

copia_img:
	ldi		XL,	low(screen)			;apunto X al primer byte de la pantalla
	ldi		XH,	high(screen)

copia_loop1:
	lpm		r17,	Z+						;traigo 1 byte a copiar a la pantalla
	st		X+,		r17						;escribo la memoria de pantalla
	cpi		XL,		low(screen_end)
	brne	copia_loop1
	cpi		XH,		high(screen_end)		;si llegué al final de la pantalla no copio más
	brne	copia_loop1
	ret

;-------------------------------------------------------------------------------------
;borra_panel:
;----------
;Rutina que borra el display LED.
;Escribe 1024 ceros en la RAM de pantalla
;-------------------------------------------------------------------------------------
borra_panel:
	ldi		XL,	low(screen)					;apunto de nuevo X al primer byte de la pantalla
	ldi		XH,	high(screen)
	ldi		r17, 0x00

borra_loop1:
	st		X+,		r17
	cpi		XL,		low(screen_end)
	brne	borra_loop1
	cpi		XH,		high(screen_end)		;si llegué al final de la pantalla no copio más
	brne	borra_loop1
	ret

;-------------------------------------------------------------------------------------
;copia_char:
;----------
;Rutina que copia un caracter en la memoria de pantalla. Por ahora pensado solo para
;los números del 0 al 9 de tamaño fijo 8x10 pixeles. Por ahora solo están el '0' y el '1'
;configurados en el mapa de caracteres pero la rutina funciona igual.
;
;los carateres son de 8x10 puntos por tanto ocupan solo 10 bytes. Esta rutina toma los 10
;bytes y bit a bit va programando la memoria de pantalla.
;
;Parámetros:
;	r18 = numero a imprimir del 0 al 9 (por ahora solo 0 y 1 disponibles)
;	r16 y r17 = Fila y Columna del pixel superior izquierdo del caracter.
;	r20 = color del caracter. 1-Verde 2-Rojo 4-Azul 3-Amarillo 5-cyan 6-lila 7-blanco 0-apagado
;-------------------------------------------------------------------------------------

copia_char:
	ldi		XL,	low(screen)				;X apunta al comienzo de la memoria de pantalla
	ldi		XH,	high(screen)

	ldi		ZL,	low(char_0<<1)			;apunto Z al comienzo del mapa de caracteres char_0
	ldi		ZH,	high(char_0<<1)

	;Ahora ajusto Z según el caracter que quiero imprimir
	ldi		r19,	0x0A
	mul		r18,	r19				;cada 0x0A es un caracter
	clc
	add		ZL,		r0
	adc		ZH,		r1

	;Ahora ajusto X segun la fila/columna donde quiero imprimir
	ldi		r18,	0x20
	mul		r16,	r18				;cada 0x20 es un salto de renglón
	clc
	add		r0,		r17				;ahora en r1:r0 está lo que me tengo que desplazar en la pantalla
	ldi		r16,	0
	adc		r1,		r16
	clc
	add		XL,		r0
	adc		XH,		r1

;ahora que esta todo listo, en este loop copio el caracter a la pantalla.
	ldi		r16,	10					;son 10 byte por caracter
copia_char1:
	lpm		r19,	Z+					;traigo 1 Byte con los bits del caracter
	ldi		r18,	8					;8 bits por byte
copia_char2:
	ld		r17,	X					;traigo 1 byte de la memoria de pantalla
	rol		r19
	brcc	copia_char3
	mov		r17,	r20					;en r20 está el color que quiero imprimir
copia_char3:
	st		X+,		r17					;guardo el byte nuevo o el que estaba antes en la memoria de pantalla
	dec		r18
	brne	copia_char2

	adiw	XL,	0x18					;avanzo 0x18 = 24 lugares para el cambio de fila en la memoria de pantalla
										;(no es 32 porque ya avancé 8 al dibujar la linea).
	dec		r16
	brne	copia_char1
	ret

;imagen ejemplo con cuadrados de colores para pruebas
Imagen_1:
.db	0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05
.db	0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05
.db	0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05
.db	0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x05, 0x05, 0x05, 0x05
.db	0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01
.db	0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01
.db	0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01
.db	0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x02, 0x05, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01
.db	0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0x06, 0x06
.db	0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0x06, 0x06
.db	0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0x06, 0x06
.db	0x02, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x01, 0x01, 0x01, 0x01, 0x06, 0x06, 0x06, 0x06
.db	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 0x01, 0x01
.db	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 0x01, 0x01
.db	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 0x01, 0x01
.db	0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x06, 0x06, 0x06, 0x06, 0x01, 0x01, 0x01, 0x01
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00
.db	0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00, 0x07, 0x07, 0x07, 0x07, 0x00, 0x00, 0x00, 0x00

;Mapa de caracteres, por ahora solo '0' y '1'
char_0:
.db 0b00111000, 0b01111100
.db 0b11000110, 0b11000110
.db 0b11000110, 0b11000110
.db 0b11000110, 0b11000110
.db 0b01111100, 0b00111000
char_1:
.db 0b00111000, 0b01111000
.db 0b00011000, 0b00011000
.db 0b00011000, 0b00011000
.db 0b00011000, 0b00011000
.db 0b00011000, 0b00111100

; RUTINAS de interrupción
;-------------------------------------------------------------------------------------

; timer0:
; --------
; rutina de barrido que saca 192 bits de RGB por el display, recordar que en
; cada paso saco 6 bits por PORTB,
; RGB0 - Pixel de la mitad de arriba
; RGB1 - Pixel de la mitad de abajo.
; RGB = color, solo puedo hacer combinaciones R, G, B, (R+G), (G+B), (R+B), y
; (R+G+B) = blanco
;
; Cada 32 Bytes de la memoria de pantalla, saco 192 bits (96 de una linea de
; arriba, 96 de una linea de abajo). En Y se supone está la dirección de
; donde comienzo a sacar los bits.
;
; Uso algunos registros exclusivos:
; 	Y (YH:YL) memoriza la dirección de pantalla que estoy recorriendo
; 	R25 memoriza la linea siguiente a iluminar
;-------------------------------------------------------------------------------------

_tmr0_int:
	; guardo contexto: registros a usar y banderas
	push	r16
	in		r16,	SREG
	push	r16
	push	r17
	push	r18
	push	XL
	push	XH

	; Y apunta a la mitad de abajo
	movw	X, Y
	; le sumo 512 a X para apuntar a la parte de abajo de la pantalla
	inc		XH
	inc		XH

	clr		r16
	; LE = 0
	cbi		PORTD, 6

LED_loop:
	; SCLK = 0
	cbi		PORTD, 5

	; traigo 2 bytes a sacar por la pantalla
	ld		r17,	Y+
	; este es de las lineas de abajo
	ld		r18,	X+

	andi	r17,	0b00000111
	swap	r18
	ror		r18
	andi	r18,	0b00111000
	or		r17, r18

	; saco RGB1 RGB0 por el puerto B
	out		PORTB,	r17

	; SCLK = 1
	sbi		PORTD, 5

	inc		r16
	cpi		r16,	32
	; loop si no completé la linea.
	brne	LED_loop

	; /OE = 1 apago display por las dudas (no es necesario, pero es por las dudas)
	sbi		PORTD, 4
	; LE = 1
	sbi		PORTD, 6

	; Ahora dibujo una nueva linea
	; NOTA: aquí ademas de pasar ABCD, estoy haciendo tambien /OE=0 y LE=0
	out		PORTD,	r25
	inc		r25
	cpi		r25,	32
	; si no llegué a la ultima linea vuelvo de la interrupción
	brne	LED_fin

	; fin de pantalla, llevo r25 y Y al principio.
	clr		r25
	ldi		YL,	low(screen)
	ldi		YH,	high(screen)

LED_fin:
	; restauro registros y banderas
	pop		XL
	pop		XH
	pop		r18
	pop		r17
	pop		r16
	out		SREG,	r16
	pop		r16
	reti

_tmr1_int:
	; guardo contexto: registros y banderas
	push	r16
	in		r16, SREG
	push	r16

	; restauro contexto
	pop		r16
	out		SREG, r16
	pop		r16

	reti
